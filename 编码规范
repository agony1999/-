C++编码规范
头文件
 
　　函数参数顺序
　　C/C++函数参数分为输入参数和输出参数两种，有时输入参数也会输出（注：值被修改时）。输入参数一般传值或常数引用（const references），输出参数戒输入/输出参数为非常数指针（non-const pointers）。对参数排序时，将所有输入参数置于输出参数之前。不要仅仅因为是新添加的参数，就将其置于最后，而应该依然置于输出参数之前。这一点并不是必须遵循的规则，输入/输出两用参数（通常是类/结构体变量）混在其中，会使得规则难以遵守。
　　个人感受：这条规则相当重要，自己写代码的时候可能没有太大感觉，但是在阅读别人代码的时候感觉特别明显。如果代码按照这种规范来写，从某种角度来说，这段代码具有“自注释”的功能，那么在看代码的时候就会比较轻松。Doom3的代码规范中提到，“Use ‘const’ as much as possible”，也是同样的意义。当然，const除了阅读方便以外，还有个很重要的就是防止编码错误，一旦在程序中修改const变量，编译器就会报错，这样就减少了人工出错了可能性，这点尤为重要！
 
　　包含文件的名称及次序
　　将包含次序标准化可增强可读性、避免隐藏依赖（hidden dependencies，注：隐藏依赖主要是指包含的文件编译），次序如下：C 库、C++库、其他库的.h、项目内的.h。
　　项目内头文件应按照项目源代码目录树结构排列，并且避免使用UNIX文件路径.（当前目录）和..（父目录）。　
　　举例来说，google-awesome-project/src/foo/internal/fooserver.cc 的包含次序如下： 
　　#include "foo/public/fooserver.h" // 优先位置 
　　
　　#include <sys/types.h> 
　　#include <unistd.h> 

　　#include <hash_map> 
　　#include <vector> 

　　#include "base/basictypes.h" 
　　#include "base/commandlineflags.h" 
　　#include "foo/public/bar.h"
　　注意，对应的头文件一定要先包含，这样避免隐藏依赖，隐藏依赖的问题不懂的可以去Google，网上有很多资料。另外，《C++编程思想》中提到的包含次序正好相反，从特殊到一般，但是有一点和Google代码规范是一样的，那就是对应的头文件是第一个包含。对于隐藏依赖的问题，以前只是习惯性的把对应的头文件放第一个，没有想过为什么，现在学习了……
 
 
作用域
 
　　全局变量
　　class 类型的全局变量是被禁止的，内建类型的全局变量是允许的，当然多线程代码中非常数全局变量也是被禁止的。永远不要使用函数返回值初始化全局变量。
　　不幸的是，全局变量的构造函数、析构函数以及初始化操作的调用顺序只是被部分规定，每次生成有可能会有变化，从而导致难以发现bug。因此，禁止使用class类型的全局变量（包括STL的string,vector等），因为它们的初始化顺序可能会导致出现问题。内建类型和由内建类型构成的没有构造函数的结构体可以使用，如果你一定要使用class类型的全局变量，请使用单件模式。
 
 
C++类
 
　　构造函数的职责
　　构造函数中只进行那些没有实际意义的初始化，可能的话，使用Init()方法集中初始化为有意义(non-trivial)的数据。
　　个人感受：这种做法可以从一开始就避免一些bug的出现，或更容易解决一些bug。构造函数+Init()函数初始化的方式与只用构造函数的方法相比，对计算机来说他们是没有区别的，但是人是会犯错的，这一条代码规范在某种程度上避免了一些人为错误，这个在开发中特别重要。
 
　　拷贝构造函数
　　仅在代码中需要拷贝一个类的对象的时候使用拷贝构造函数，不需要拷贝时使用DISALLOW_COPY_AND_ASSIGN这个宏（关于这个宏的内容，可以在网上搜到，我这里就不写了）。C++中对象的隐式拷贝是导致很多性能问题和bugs的根源。拷贝构造函数降低了代码可读性，相比按引用传递，跟踪按值传递的对象更加困难，对象修改的地方变得难以捉摸。
　　个人感受：和上一项的目的类似，为了避免人为错误！拷贝构造函数本来是为了方便程序员编程了，但是却有可能成为一个坑，为了避免这类问题，不需要拷贝时使用DISALLOW_COPY_AND_ASSIGN，这样在需要调用拷贝构造函数的时候就会报错，减少了人为出错的可能性。C#和Java在这方面就做得比较好，虽然性能上不如C++，但是人为出错的概率减少了很多。当然，使用一定的代码规范，可以在一定程度上减少C++的坑。
 
　　继承
　　虽然C++的继承很好用，但是在实际开发中，尽量多用组合少用继承，不懂的去看GoF的《Design Patterns》。
　　但重定义派生的虚函数时，在派生类中明确声明其为virtual。这一条是为了为了阅读方便，虽然从语法的角度来说，在基类中声明了virtual，子类可以不用再声明该函数为virtual，但这样一来阅读代码的人需要检索类的所有祖先以确定该函数是否为虚函数o(╯□╰)o。
 
　　多重继承
　　虽然允许，但是只能一个基类有实现，其他基类是接口，这样一来和JAVA一样了。这些东西在C#和JAVA中都进行了改进，直接从语法上解决问题。C++的灵活性过高，也是个麻烦的问题，只能通过代码规范填坑。
 
　　接口
　　虚基类必须以Interface为后缀，方便阅读。阅读方便。
 
　　重载操作符
　　除少数特定情况外，不要重载操作符！！！“==”和“=”的操作Euqals和CopyFrom函数代替，这样更直观，也不容易出错。
　　个人感受：看到这一条，我有点惊讶，在学习C++的时候，说重载操作符有神马神马好处，为什么现在又说不要重载操作符呢？仔细看了他的文档，确实说的有道理，导致可能出现的bug见其具体文档。在实际应用中，由于C++的坑实在太多了，不得不把这种“好用”的东西干掉，因为出了bug又找不到，是一件很O疼的事情。
 
　　声明次序
　　1）typedefs和enums；
　　2）常量；
　　3）构造函数；
　　4）析构函数；
　　5）成员函数，含静态成员函数；
　　6）数据成员，含静态数据成员。
　　宏 DISALLOW_COPY_AND_ASSIGN 置于private:块之后，作为类的最后部分。
 
 
其他 C++ 特性
 
　　引用参数
　　函数形参表中，所有的引用必须的const！
　　个人感受：这么做是为了防止引用引起的误解，因为引用在语法上是值，却有指针的意义。虽然引用比较好用，但是牺牲其某些方面的特性，换来软件管理方面的便利，还是很值得了。
 
　　缺省参数
　　禁止使用函数缺省参数！
　　个人感受：看到这一点的时候觉得有点因噎废食了，其实缺省参数感觉还是蛮好用的。当然从另外一个角度来说，要使用C++就不要怕这种小麻烦，如果因为使用这些特性造成了找不到的bug，那会损失更多时间。
 
　　异常
　　不要使用 C++异常。
　　这一点我没有看懂，也许是因为它的异常机制没有C#和Java那么完善吧……毕竟在C#和Java里面异常还是很好用的东东。
 
　　流
　　除了记录日志，不要使用流，使用printf之类的代替。
　　这一条其实是有一些争议的，当然大多数人认为代码一致性比较重要，所以选择printf，具体的可以看原文文档。
 
　　const 的使用
　　在任何可以的情况下都要使用const。
　　这条规则赞一个，Doom3的代码规范里也提到了这一条。这么做有两个好处，一个是防止程序出错，因为修改了const类型的变量会报错；另一个就是方便阅读，使代码“自注释”。虽然这么做也有坏处，当然，总体来说利大于弊。
 
 
命名约定
 
　　1、总体规则：不要随意缩写，如果说 ChangeLocalValue 写作ChgLocVal还有情可原的话，把ModifyPlayerName写作MdfPlyNm就太过分了，除函数名可适当为动词外，其他命名尽量使用清晰易懂的名词； 
　　2、宏、枚举等使用全部大写+下划线； 
　　3、变量（含类、结构体成员变量）、文件、命名空间、存取函数等使用全部小写+下划线，类成员变量以下划线结尾，全局变量以g_开头； 
　　4、普通函数、类型（含类与结构体、枚举类型）、常量等使用大小写混合，不含下划线； 
　　使用这套命名约定，可以使代码具有一定程度的“自注释”功能，方便他人阅读，也方便自己以后修改。当然3、4两点也可以使用其他的命名约定，只要团队统一即可。
 
格式　
 
　　1、行宽原则上不超过80列，把22寸的显示屏都占完，怎么也说不过去；
　　2、尽量不使用非ASCII字符，如果使用的话，参考 UTF-8 格式（尤其是 UNIX/Linux 下，Windows 下可以考虑宽字符），尽量不将字符串常量耦合到代码中，比如独立出资源文件，返不仅仅是风格问题了；
　　3、UNIX/Linux下无条件使用空格，MSVC的话使用 Tab 也无可厚非； （我没用过Linux，不懂为什么在Linux下无条件使用空格）
　　4、函数参数、逻辑条件、初始化列表：要么所有参数和函数名放在同一行，要么所有参数并排分行；
　　5、除函数定义的左大括号可以置于行首外，包括函数/类/结极体/枚举声明、各种语句的左大括号置于行尾，所有右大括号独立成行；
　　6、./->操作符前后丌留空格，*/&不要前后都留，一个就可，靠左靠右依各人喜好；
　　7、预处理指令/命名空间不使用额外缩进，类/结构体/枚举/函数/语句使用缩进；
　　8、初始化用=还是()依个人喜好，统一就好；
　　9、return不要加()；
　　10、水平/垂直留白不要滥用，怎么易读怎么来。

一、java文件组织

文件组织规则：由于超过2000行的程序难以阅读，应该尽量避免出现超过2000行的程序。一个Java源文件都包含一个单一的公共类或接口。若私有类和接口与一个公共类相关联，可以将它们和公共类放入同一个源文件。公共类必须是这个文件中的第一个类或接口。

文件组织顺序：

1.文件注释：所有的源文件都应该在开头有一个注释，其中列出文件的版权声明、文件名、功能描述以及创建、修改记录：



2.包和引入语句：在多数Java源文件中，第一个非注释行是包语句。在它之后可以跟导包语句

3. 类或接口注释：采用JavaDoc文档注释，在类、接口定义之前应当对其进行注释，包括类、接口的描述、最新修改者、版本号、参考链接等；



注：JavaDoc文档注释：描述Java的类、接口、构造方法、方法、以及字段。每个文档注释都会被置于注释定界符/**...*/之中，一个注释对应一个类、接口或成员。该注释应位于声明之前。文档注释的第一行(/**)不需缩进，随后的文档注释每行都缩进1格(使星号纵向对齐)。

4. 类或接口的声明

5. 类或接口的实现注释：如果有关类或接口的信息不适合作为“类或接口文档注释”，可以在类或接口的实现注释中给出；

6. 类的（静态）变量：首先是类的公共变量，随后是保护变量，再后是包一级别的变量（没有访问修饰符），最后是私有变量；

7. 实例变量：首先是公共级别的，随后是保护级别的，再后是包一级别的（没有访问修饰符），最后是私有级别的；

8. 构造方法；

9. 普通方法：方法应该按功能分组，而不应该按作用域或访问权限进行分组。

二、代码风格

      1.缩进：程序块要采用缩进风格编写，缩进只使用TAB键，不能使用空格键（编辑器中请将TAB设置为4格）；方法体的开始、类的定义、以及if、for、do、while、switch、case语句中的代码都要采用缩进方式；

      2.对齐：程序块的分界符左大括号"{" 和右大括号"}"都另起一行，应各独占一行并且位于同一列，同时与引用它们的语句左对齐；对齐只使用TAB键，不使用空格键；不允许把多个短语句写在一行中，即一行只写一条语句；if、for、do、while、case、switch、default等语句自占一行。

      3.换行：一行的长度超过80个字符需要换行，换行规则如下：

在一个逗号后面断开；

在一个操作符前面断开；

长表达式要在低优先级操作符处划分新行；

新行缩进2个TAB。

4.间隔：类、方法及相对独立的程序块之间、变量说明之后必须加空行；关键字之后要留空格， 象if、for、while  等关键字之后应留一个空格再跟左括号"（"， 以突出关键字；方法名与其左括号"（"之间不要留空格, 以与关键字区别；二元操作符如   " ="、" +="  " >="、" <="、" +"、" *"、" %"、" &&"、" ||"、" <<" ," ^" 等的前后应当加空格；一元操作符如" !"、" ~"、" ++"、" --"等前后不加空格；xiang"［ ］"、" ." 这类操作符前后不加空格；for语句中的表达式应该被空格分开；强制转型后应该跟一个空格。

三、注释

1.原则：对已经不推荐使用的类和方法需要注明@Deprecated，并说明替代的类或者方法；对于针对集合、开关的方法，要在方法注释中表明是否多线程安全。

2．字段注释: 采用JavaDoc文档注释，定义为public的字段必需给出注释，在类的(静态)变量、实例变量定义之前当对其进行注释，给出该字段的描述等：



3.方法注释：采用JavaDoc文档注释，在方法定义之前当对其进行注释，包括方法的描述、输入、输出及返回值说明、抛出异常说明、参考链接等：



4.单行注释格式//

6.多行注释格式/*……*/

三、命名规则

1.基本规则:使用可以准确说明变量、字段、类、接口、包等完整的英文描述符；采用大小写混合，提高名字的可读性；采用该领域的术语；尽量少用缩写，但如果一定要使用，当使用公共缩写和习惯缩写等；避免使用相似或者仅在大小写上有区别的名字。

2.包命名：包名一律小写, 少用缩写和长名；采用以下规则：

                                  [基本包].[项目名].[模块名].[子模块名]...

不得将类直接定义在基本包下，所有项目中的类、接口等都应当定义在各自的项目和模块包中。

3.类或接口命名：类或接口名是个一名词，采用大小写混合的方式，每个单词的首字母大写。尽量使你的类名简洁而富于描述。使用完整单词，避免用缩写词(除非该缩写词被更广泛使用，像URL，HTML)。

4.变量命名: 采用大小写混合的方式，第一个单词的首字母小写，其后单词的首字母大写；变量名不应以下划线或美元符号开头；尽量避免单个字符的变量名，除非是一次性的临时变量。临时变量通常被取名为i，j，k，m和n，它们一般用于整型；c，d，e，它们一般用于字符型；不采用匈牙利命名法则，对不易清楚识别出该变量类型的变量应使用类型名或类型名缩写作其后缀；组件或部件变量使用其类型名或类型名缩写作其后缀；集合类型变量，例如数组和矢量，应采用复数命名或使用表示该集合的名词做后缀。

5.常量命名：全部采用大写，单词间用下划线隔开。

6．方法命名：方法名是一个动词，采用大小写混合的方式，第一个单词的首字母小写，其后单词的首字母大写；取值类可使用get前缀，设值类可使用set前缀，判断类可使用is(has)前缀。

四、声明

1.类或接口的声名：类、接口定义语法规范如下

[可见性][('abstract'|'final')] [Class|Interface] class_name

[('extends'|'implements')][父类或接口名]{

//方法体

}

2.方法声明：良好的程序设计应该尽可能减小类与类之间耦合，所遵循的经验法则是：尽量限制成员函数的可见性。如果成员函数没必要公有 (public)，就定义为保护 (protected)；没必要保护 (protected)，就定义为私有 (private)；方法定义语法规范：

[可见性]['abstract'] [‘static’] ['final'] ['synchronized'][返回值类型] method_name(参数列表)[('throws')][异常列表]{

//方法体

}

声明顺序：构造方法、静态公共方法、静态私有方法、公共方法、友元方法、受保护方法、私有方法、main方法；方法参数建议顺序：(被操作者，操作内容，操作标志，其他)。

3.变量声明：一行一个声明；声明局部变量的同时初始化（在变量的初始值依赖于某些先前发生的计算的特殊情况下可以不用同时初始化）；只在代码块的开始处声明变量，（一个块是指任何被包含在大括号"{"和"}"中间的代码）不要在首次用到该变量时才声明；避免声明的局部变量覆盖上一级声明的变量，即不要在内部代码块中声明相同的变量名；公共和保护的可见性应当尽量避免，所有的字段都建议置为私有，由获取和设置成员函数（Getter、Setter）访问；定义一个变量或者常量的时候，不要包含包名（类似java.security.MessageDigest digest = null），除非是两个包有相同的类名；数组声明时应当将"[]"跟在类型后，而不是字段名后；声明顺序：常量、类变量、实例变量、公有字段、受保护字段、友元字段、私有字段。

五、异常

      1.捕捉异常的目的是为了处理它

      2. 多个异常应分别捕捉并处理，避免使用一个单一的catch来处理。

六、习惯

1. if、for、do、while等语句的执行语句部分无论多少都要加括号"{}"

2. 每当一个case顺着往下执行时(因为没有break语句)，通常应在break语句的位置添加注释；

3. 尽量避免在循环中构造和释放对象

4. 在使用局部变量的过程，按就近原则处理。不允许定义一个局部变量，然后在很远的地方才使用；

5.相同的功能不允许复制成N份代码；

6. 在处理 String 的时候要尽量使用 StringBuffer 类。

